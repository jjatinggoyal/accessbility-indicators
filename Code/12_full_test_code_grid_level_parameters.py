# -*- coding: utf-8 -*-
"""12_Full_Test_Code_grid_level_parameters.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jDDJ5XRvHNmfXRlDr43pBT7aFzmioS_m
"""



from google.colab import drive #to retrieve data from drive 
drive.mount('/content/drive/')

cd 'drive/My Drive/Data/Input_Data'

pwd

import numpy as np
import pandas as pd
from scipy.spatial import Voronoi, voronoi_plot_2d
import matplotlib.pyplot as plt
import math
from sklearn.metrics.pairwise import haversine_distances
from math import radians
import pickle as pkl
import time

def filter_data(district_name):
  import re
  dist_results = pd.read_csv(district_name+"_2019_all_indicators"+".csv")
  dist_results=dist_results.to_numpy()
  dist_results=dist_results[:,0:2]
  lat_coord=np.array([])
  lon_coord=np.array([])
  for i in range(dist_results.shape[0]):
    temp=re.split('\[|\]|,| ',dist_results[i,1])
    lat_coord=np.append(lat_coord,(float(temp[1])+0.005))
    lon_coord=np.append(lon_coord,(float(temp[3])+0.005))
  lat_coord=(lat_coord.reshape(lat_coord.shape[0],1))
  lon_coord=(lon_coord.reshape(lon_coord.shape[0],1))
  dist_results=dist_results[:,0].reshape(dist_results.shape[0],1)
  dist_results=np.append(dist_results,lat_coord,axis=1)
  dist_results=np.append(dist_results,lon_coord,axis=1)
  return dist_results

def lat_lon_to_grid_no(lat, lon, min_lat, max_lat, min_lon, max_lon):
  num_rows = np.round((max_lat - min_lat)/0.01).astype(int)
  num_cols = np.round((max_lon - min_lon)/0.01).astype(int)
  row_id_from_bottom = np.maximum(1, np.ceil((lat - min_lat)*100))
  row_id_from_bottom = np.minimum(row_id_from_bottom, num_rows) 
  col_id_from_left = np.maximum(1, np.ceil((lon - min_lon)*100))
  col_id_from_left = np.minimum(col_id_from_left, num_cols)
  grid_no = (col_id_from_left-1)*num_rows + row_id_from_bottom
  return grid_no.astype(int)

def calc_hvs_dist(arr):#returns distance in meters
  # arr = np.append(grid_centre,grid_amenity_arr, axis=0)
  arr_in_radians = np.radians(arr)
  result_arr = haversine_distances(arr_in_radians)
  result_arr = (result_arr * 6371000)[0,1:]
  hvs_dist = np.min(result_arr)
  return hvs_dist

def extract_boundaries(district_name):
  dist_coords = pd.read_csv("district_coordinates.csv")
  min_lat = np.floor(float(dist_coords.loc[dist_coords['District_Name'] == district_name]['MinLat'])*100)/100
  max_lat = np.ceil(float(dist_coords.loc[dist_coords['District_Name'] == district_name]['MaxLat'])*100)/100
  min_lon = np.floor(float(dist_coords.loc[dist_coords['District_Name'] == district_name]['MinLong'])*100)/100
  max_lon = np.ceil(float(dist_coords.loc[dist_coords['District_Name'] == district_name]['MaxLong'])*100)/100
  return (min_lat,min_lon,max_lat,max_lon)

def calc_difference_dist(arr):
  # print('arr',arr)
  arr_in_radians = np.radians(arr)
  # print('arr in radians')
  # print(arr_in_radians)
  result_arr = haversine_distances(arr_in_radians)
  # print('result_arr',result_arr)
  result_arr_row_0 = (result_arr * 6371000)[0,1:]
  sorted_dist_arr = np.sort(result_arr_row_0)
  # print('result_arr_row0',result_arr_row_0)
  # print('sorted_sidt_arr',sorted_dist_arr)
  # print("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^")
  difference_dist = sorted_dist_arr[1]-sorted_dist_arr[0]
  return difference_dist

def evaluate_grid_level_parameters(district_name, amenity_type, parameter_index):
  #parameter index details
  # 1 - bfs for nearest amenity distance
  # 2 - distance between 2nd nearest and nearest amenity
  grids_arr = filter_data(district_name)
  pkl_file_name=district_name.lower()+'.pkl'
  with open(pkl_file_name, 'rb') as f:
      amenity_dict = pkl.load(f, encoding='latin1')
  grids_amenity_arr = amenity_dict[amenity_type.lower()]
  (min_lat,min_lon,max_lat,max_lon) = extract_boundaries(district_name)
  result_arr=np.array([])
  for i in range(grids_arr.shape[0]):#grids_arr.shape[0]):
    amenity_coll_arr=np.array([[np.around(grids_arr[i][1],3),np.around(grids_arr[i][2],3)]])
    visited_grid_num=np.zeros(grids_arr.shape[0])
    level_grid_num=np.zeros(grids_arr.shape[0])
    last_level=float('inf')
    found=0
    queue=[]
    queue.append(i)
    visited_grid_num[i]=1
    while queue:
      node=queue.pop(0)
      curr_lat=np.around(grids_arr[node][1],3)
      curr_lon=np.around(grids_arr[node][2],3)
      if (level_grid_num[node]==last_level):
        break
      specific_grid_amenity_arr=grids_amenity_arr[node]
      if (np.all(specific_grid_amenity_arr==None)):
        len_specific_grid_amenity_arr=0
      else:
        len_specific_grid_amenity_arr=len(specific_grid_amenity_arr)
      if (len_specific_grid_amenity_arr != 0):
        if (parameter_index == 1):
          if (found==0):
            found=1
            last_level=level_grid_num[node]+2
        if (parameter_index == 2):
          if (found==0 and len(amenity_coll_arr)>=3):
            found=1
            last_level=level_grid_num[node]+2
        amenity_coll_arr=np.append(amenity_coll_arr,specific_grid_amenity_arr,axis=0)
      right_lat=curr_lat
      right_lon=curr_lon+0.01
      if (right_lat<min_lat or right_lat>max_lat or right_lon<min_lon or right_lon>max_lon):
        pass
      else:
        right_grid=lat_lon_to_grid_no(right_lat,right_lon,min_lat,max_lat,min_lon,max_lon)-1
        if (visited_grid_num[right_grid]==0):
          level_grid_num[right_grid]=level_grid_num[node]+1
          queue.append(right_grid)
          visited_grid_num[right_grid]=1
      left_lat=curr_lat
      left_lon=curr_lon-0.01
      if (left_lat<min_lat or left_lat>max_lat or left_lon<min_lon or left_lon>max_lon):
        pass
      else:
        left_grid=lat_lon_to_grid_no(left_lat,left_lon,min_lat,max_lat,min_lon,max_lon)-1
        if (visited_grid_num[left_grid]==0):
          level_grid_num[left_grid]=level_grid_num[node]+1
          queue.append(left_grid)
          visited_grid_num[left_grid]=1
      top_lat=curr_lat+0.01
      top_lon=curr_lon
      if (top_lat<min_lat or top_lat>max_lat or top_lon<min_lon or top_lon>max_lon):
        pass
      else:
        top_grid=lat_lon_to_grid_no(top_lat,top_lon,min_lat,max_lat,min_lon,max_lon)-1
        if (visited_grid_num[top_grid]==0):
          level_grid_num[top_grid]=level_grid_num[node]+1
          queue.append(top_grid)
          visited_grid_num[top_grid]=1
      bottom_lat=curr_lat-0.01
      bottom_lon=curr_lon
      if (bottom_lat<min_lat or bottom_lat>max_lat or bottom_lon<min_lon or bottom_lon>max_lon):
        pass
      else:
        bottom_grid=lat_lon_to_grid_no(bottom_lat,bottom_lon,min_lat,max_lat,min_lon,max_lon)-1
        if (visited_grid_num[bottom_grid]==0):
          level_grid_num[bottom_grid]=level_grid_num[node]+1
          queue.append(bottom_grid)
          visited_grid_num[bottom_grid]=1
    if (parameter_index == 1):
      hvs_distance=calc_hvs_dist(amenity_coll_arr)
      result_arr=np.append(result_arr,np.array([hvs_distance]))
    if (parameter_index == 2):
      difference_distance=calc_difference_dist(amenity_coll_arr)
      result_arr=np.append(result_arr,np.array([difference_distance]))
  return result_arr

# NOOO NEED

def create_nearest_amenity_distance_from_each_centre_csv_file(district_name, category_name, category_list):
  distance_list=[]
  for i in range(len(category_list)):
    distance_list.append(evaluate_grid_level_parameters(district_name, category_list[i], 1))
  # (np.shape(ans)[0])
  ans=distance_list[0]
  for i in range(len(distance_list)-1):
    ans=np.minimum(ans,distance_list[i+1])
  data = {'Grid_Number': [i for i in range(0, np.shape(ans)[0])], category_name: ans/1000.0}
  df = pd.DataFrame(data, columns = data.keys())
  df.to_csv(district_name + '/' + district_name + '_nearest_'+category_name+'_from_each_grid_centre.csv', index=False)#distance is in km

start_time=time.time()
# districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
category_dict={"Education":['school','primary_school'],"Health":['doctor','hospital'],"Connectivity":['train_station','taxi_stand','bus_station'],"Utilities":['department_store','supermarket'],"Government_Facilities":['local_government_office','police','bank']}
# category_dict={"Connectivity":['train_station','taxi_stand','bus_station'],"Utilities":['department_store','supermarket'],"Government_Facilities":['local_government_office','police','bank']}
districts=['Dhanbad']
for i in range(len(districts)):
  for key in category_dict:
    create_nearest_amenity_distance_from_each_centre_csv_file(districts[i],key,category_dict[key])#distance is in km
    print('done for district '+districts[i]+' for category '+key+' in time ',time.time()-start_time)

# Now you can

# def create_difference_distance_bw_nearest_next_nearest_amenity_from_each_centre_csv_file(district_name, category_name, category_list):
#   diff_dist_list=[]
#   for i in range(len(category_list)):
#     diff_dist_list.append(evaluate_grid_level_parameters(district_name, category_list[i], 2))
#   ans=diff_dist_list[0]
#   # (np.shape(ans)[0])
#   for i in range(len(diff_dist_list)-1):
#     ans=np.minimum(ans,diff_dist_list[i+1])
#   data = {'Grid_Number': [i for i in range(0, np.shape(ans)[0])], category_name: ans/1000.0}
#   df = pd.DataFrame(data, columns = data.keys())
#   df.to_csv(district_name + '_difference_distance_bw_nearest_next_nearest_'+category_name+'_from_each_grid_centre.csv', index=False)#distance is in km

# districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
# category_dict={"Education":['school','primary_school'],"Health":['doctor','hospital'],"Connectivity":['train_station','taxi_stand','bus_station'],"Utilities":['department_store','supermarket'],"Government_Facilities":['local_government_office','police','bank']}
# for i in range(len(districts)):
#   start_time=time.time()
#   for key in category_dict:
#     create_difference_distance_bw_nearest_next_nearest_amenity_from_each_centre_csv_file(districts[i],key,category_dict[key])
#     print('done for district '+districts[i]+' for category '+key+' in time ',time.time()-start_time)

def get_grid_info(district_name,year):
  import re
  dist_results = pd.read_csv(district_name+"_"+str(year)+"_all_indicators"+".csv")
  dist_results=dist_results.to_numpy()
  grid_type_arr=(dist_results[:,7]).reshape(dist_results.shape[0],1)
  grid_class_arr=(dist_results[:,11]).reshape(dist_results.shape[0],1)
  dist_results=dist_results[:,0:2]
  lat_coord=np.array([])
  lon_coord=np.array([])
  for i in range(dist_results.shape[0]):
    temp=re.split('\[|\]|,| ',dist_results[i,1])
    lat_coord=np.append(lat_coord,(float(temp[1])+0.005))
    lon_coord=np.append(lon_coord,(float(temp[3])+0.005))
  lat_coord=(lat_coord.reshape(lat_coord.shape[0],1))
  lon_coord=(lon_coord.reshape(lon_coord.shape[0],1))
  dist_results=dist_results[:,0].reshape(dist_results.shape[0],1)
  dist_results=np.append(dist_results,lat_coord,axis=1)
  dist_results=np.append(dist_results,lon_coord,axis=1)
  dist_results=np.append(dist_results,grid_type_arr,axis=1)
  dist_results=np.append(dist_results,grid_class_arr,axis=1)
  return dist_results

def count_amenities_in_range(arr, last_level):
  arr_in_radians = np.radians(arr)
  # print('arr in radians')
  # print(arr_in_radi/ans)
  result_arr = haversine_distances(arr_in_radians)
  # print('result_arr',result_arr)
  result_arr_row_0 = (result_arr * 6371000)[0,1:]
  sorted_dist_arr = np.sort(result_arr_row_0)
  # print('result_arr_row0',result_arr_row_0)
  # print('sorted_sidt_arr',sorted_dist_arr)
  # print("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^")
  # difference_dist = sorted_dist_arr[1]-sorted_dist_arr[0]
  if (last_level==4):
    dist_limit=2000
  elif (last_level==1):
    dist_limit=400
  elif (last_level==3):
    dist_limit=800
  else:
    dist_limit=5000
  num_amenities=0
  for i in range(len(sorted_dist_arr)):
    if (sorted_dist_arr[i] > dist_limit):
      num_amenities=i+1
      break
  return num_amenities

def evaluate_num_grids(district_name,amenity_type,year):
  grids_arr = get_grid_info(district_name,year)#year=2016 or 2019
  pkl_file_name=district_name.lower()+'.pkl'
  with open(pkl_file_name, 'rb') as f:
      amenity_dict = pkl.load(f, encoding='latin1')
  grids_amenity_arr = amenity_dict[amenity_type.lower()]
  (min_lat,min_lon,max_lat,max_lon) = extract_boundaries(district_name)
  result_arr=np.array([])
  for i in range(grids_arr.shape[0]):
    amenity_coll_arr=np.array([[np.around(grids_arr[i][1],3),np.around(grids_arr[i][2],3)]])
    visited_grid_num=np.zeros(grids_arr.shape[0])
    level_grid_num=np.zeros(grids_arr.shape[0])
    grid_status=grids_arr[i][3]
    if (grid_status=='Rejected' or grid_status=='Rural'):
      last_level=10
    else:
      if (amenity_type=='taxi_stand' or amenity_type=='bus_station'):
        last_level=1
      elif (amenity_type=='supermarket' or amenity_type=='department_store' or amenity_type=='train_station'):
        last_level=3
      else:
        last_level=4
    # last_level=float('inf')
    # found=0
    queue=[]
    queue.append(i)
    visited_grid_num[i]=1
    while queue:
      node=queue.pop(0)
      curr_lat=np.around(grids_arr[node][1],3)
      curr_lon=np.around(grids_arr[node][2],3)
      if (level_grid_num[node]==last_level):
        break
      specific_grid_amenity_arr=grids_amenity_arr[node]
      if (np.all(specific_grid_amenity_arr==None)):
        len_specific_grid_amenity_arr=0
      else:
        len_specific_grid_amenity_arr=len(specific_grid_amenity_arr)
      if (len_specific_grid_amenity_arr != 0):
        # if (parameter_index == 1):
        #   if (found==0):
        #     found=1
        #     last_level=level_grid_num[node]+2
        # if (parameter_index == 2):
        #   if (found==0 and len(amenity_coll_arr)>=3):
        #     found=1
        #     last_level=level_grid_num[node]+2
        amenity_coll_arr=np.append(amenity_coll_arr,specific_grid_amenity_arr,axis=0)
      right_lat=curr_lat
      right_lon=curr_lon+0.01
      if (right_lat<min_lat or right_lat>max_lat or right_lon<min_lon or right_lon>max_lon):
        pass
      else:
        right_grid=lat_lon_to_grid_no(right_lat,right_lon,min_lat,max_lat,min_lon,max_lon)-1
        if (visited_grid_num[right_grid]==0):
          level_grid_num[right_grid]=level_grid_num[node]+1
          queue.append(right_grid)
          visited_grid_num[right_grid]=1
      left_lat=curr_lat
      left_lon=curr_lon-0.01
      if (left_lat<min_lat or left_lat>max_lat or left_lon<min_lon or left_lon>max_lon):
        pass
      else:
        left_grid=lat_lon_to_grid_no(left_lat,left_lon,min_lat,max_lat,min_lon,max_lon)-1
        if (visited_grid_num[left_grid]==0):
          level_grid_num[left_grid]=level_grid_num[node]+1
          queue.append(left_grid)
          visited_grid_num[left_grid]=1
      top_lat=curr_lat+0.01
      top_lon=curr_lon
      if (top_lat<min_lat or top_lat>max_lat or top_lon<min_lon or top_lon>max_lon):
        pass
      else:
        top_grid=lat_lon_to_grid_no(top_lat,top_lon,min_lat,max_lat,min_lon,max_lon)-1
        if (visited_grid_num[top_grid]==0):
          level_grid_num[top_grid]=level_grid_num[node]+1
          queue.append(top_grid)
          visited_grid_num[top_grid]=1
      bottom_lat=curr_lat-0.01
      bottom_lon=curr_lon
      if (bottom_lat<min_lat or bottom_lat>max_lat or bottom_lon<min_lon or bottom_lon>max_lon):
        pass
      else:
        bottom_grid=lat_lon_to_grid_no(bottom_lat,bottom_lon,min_lat,max_lat,min_lon,max_lon)-1
        if (visited_grid_num[bottom_grid]==0):
          level_grid_num[bottom_grid]=level_grid_num[node]+1
          queue.append(bottom_grid)
          visited_grid_num[bottom_grid]=1
    # if (parameter_index == 1):
    #   hvs_distance=calc_hvs_dist(amenity_coll_arr)
    #   result_arr=np.append(result_arr,np.array([hvs_distance]))
    # if (parameter_index == 2):
    #   difference_distance=calc_difference_dist(amenity_coll_arr)
    #   result_arr=np.append(result_arr,np.array([difference_distance]))
    if (len(amenity_coll_arr)==1):
      num_amenitites=0
    else:
      num_amenitites=count_amenities_in_range(amenity_coll_arr, last_level)
    result_arr=np.append(result_arr,num_amenitites)
  return result_arr

# NO NEED TO RUN


# NO NEED TO RUN

def create_num_amenities_within_std_range_from_each_centre_csv_file(district_name, category_name, category_list, year):
  num_list=[]
  for i in range(len(category_list)):
    num_list.append(evaluate_num_grids(district_name, category_list[i], year))
  ans=num_list[0]
  # (np.shape(ans)[0])
  for i in range(len(num_list)-1):
    ans=np.add(ans,num_list[i+1])
  data = {'Grid_Number': [i for i in range(0, np.shape(ans)[0])], category_name: ans}
  df = pd.DataFrame(data, columns = data.keys())
  df.to_csv(district_name + '/' + district_name + '_num_'+category_name+'_within_std_range_from_each_grid_centre_'+str(year)+'.csv', index=False)

# districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
category_dict={"Education":['school','primary_school'],"Health":['doctor','hospital'],"Connectivity":['train_station','taxi_stand','bus_station'],"Utilities":['department_store','supermarket'],"Government_Facilities":['local_government_office','police','bank']}
districts=['Dhanbad']
# category_dict={"Government_Facilities":['local_government_office','police','bank']}
for i in range(len(districts)):
  for key in category_dict:
    start_time=time.time()
    create_num_amenities_within_std_range_from_each_centre_csv_file(districts[i],key,category_dict[key],2019)
    # create_num_amenities_within_std_range_from_each_centre_csv_file(districts[i],amenities[j],2016)
    print('done for district '+districts[i]+' for category '+key+' in time ',time.time()-start_time)

# NOW YOU CAN


# NOW YOU CAN

def create_num_amenities_in_each_grid_csv_file(district_name, category_name, category_list):
  num_list=[]
  pkl_file_name=district_name.lower()+'.pkl'
  with open(pkl_file_name, 'rb') as f:
      amenity_dict = pkl.load(f, encoding='latin1')
  for j in range(len(category_list)):
    grids_amenity_arr = amenity_dict[(category_list[j]).lower()]
    num_arr=np.array([])
    for i in range(len(grids_amenity_arr)):
      if (np.all(grids_amenity_arr[i]==None)):
        len_arr=0
      else:
        len_arr=len(grids_amenity_arr[i])
      num_arr=np.append(num_arr,len_arr)
    num_list.append(num_arr)
  ans=num_list[0]
  for j in range(len(num_list)-1):
    ans=np.add(ans,num_list[j+1])
  data = {'Grid_Number': [i for i in range(0, np.shape(ans)[0])], category_name: ans}
  df = pd.DataFrame(data, columns = data.keys())
  df.to_csv(district_name + '/' + district_name + '_num_'+category_name+'_in_each_grid'+'.csv', index=False)

# districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
category_dict={"Education":['school','primary_school'],"Health":['doctor','hospital'],"Connectivity":['train_station','taxi_stand','bus_station'],"Utilities":['department_store','supermarket'],"Government_Facilities":['local_government_office','police','bank']}
districts=['Jamui']
# category_dict={"Education":['school','primary_school'],"Health":['doctor','hospital'], "Utilities":['department_store','supermarket'],"Connectivity":['train_station','taxi_stand','bus_station']}
for i in range(len(districts)):
  for key in category_dict:
    start_time=time.time()
    create_num_amenities_in_each_grid_csv_file(districts[i],key,category_dict[key])
    print('done for district '+districts[i]+' for category '+key+' in time ',time.time()-start_time)

# def create_csv_file_for_cdf_for_combined_grids_for_nearest_amenity_dist(district_name,amenity_type,year):
#   filename = district_name + '_nearest_'+amenity_type+'_from_each_centre_grid.csv'
#   grids_info=get_grid_info(district_name,year)
#   num_arr=pd.read_csv(filename)
#   num_arr=num_arr.to_numpy()
#   num_arr = num_arr[:,1] 
#   grid_num=np.arange(num_arr.shape[0])
#   grid_num=grid_num[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
#   combined_grids_dist=num_arr[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
#   data = {'Grid_Number': grid_num, amenity_type: combined_grids_dist}
#   df = pd.DataFrame(data, columns = data.keys())
#   df.to_csv('CDF_plot_data_of_combined_grids_for_'+district_name + '_for_nearest_'+amenity_type+'_distance_in_km'+'.csv', index=False)

# districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
# amenities=['local_government_office','school','police','doctor','train_station','department_store','supermarket','primary_school','taxi_stand','bus_station','hospital','bank']
# for i in range(len(districts)):
#   for j in range(len(amenities)):
#     start_time=time.time()
#     create_csv_file_for_cdf_for_combined_grids_for_nearest_amenity_dist(districts[i],amenities[j],2019)
#     print('done for district '+districts[i]+' for amenity '+amenities[j]+' in time ',time.time()-start_time)

def percentile_value_for_nearest_amenity_dist_for_combined_grids(district_name,category_name,year,i):#using 80 percentile distance
  filename = district_name + '/' + district_name + '_nearest_'+category_name+'_from_each_grid_centre.csv'
  grids_info=get_grid_info(district_name,year)
  num_arr=pd.read_csv(filename)
  num_arr=num_arr.to_numpy()
  num_arr = num_arr[:,1] 
  filename=district_name + '/' + district_name+'_grid_population.csv'
  grids_info=get_grid_info(district_name,year)
  pop_arr=pd.read_csv(filename)
  pop_arr=pop_arr.to_numpy()
  mod_pop_arr = pop_arr[:,2]
  # grid_num=np.arange(num_arr.shape[0])
  # grid_num=grid_num[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
  if i == 0:
    combined_grids_dist=num_arr[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
  elif i == 1:
    combined_grids_dist=num_arr[(grids_info[:,3]=='Rural')]
  elif i == 2:
    combined_grids_dist=num_arr[np.logical_and((grids_info[:,3]!='Rejected'),(mod_pop_arr==1))]
  return_value = np.percentile(combined_grids_dist,80)
  return return_value
  # data = {'Grid_Number': grid_num, amenity_type: combined_grids_dist}
  # df = pd.DataFrame(data, columns = data.keys())
  # df.to_csv('CDF_plot_data_of_combined_grids_for_'+district_name + '_for_nearest_'+amenity_type+'_distance_in_km'+'.csv', index=False)

# districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
category_dict={"Education":[],"Health":[],"Connectivity":[],"Utilities":[],"Government_Facilities":[]}
districts=['Jamui']
for x in range(3):
  category_dict={"Education":[],"Health":[],"Connectivity":[],"Utilities":[],"Government_Facilities":[]}
  for i in range(len(districts)):
    for key in category_dict:
      start_time=time.time()
      category_dict[key].append(percentile_value_for_nearest_amenity_dist_for_combined_grids(districts[i],key,2019,x))
      print('done for district '+districts[i]+' for category '+key+' in time ',time.time()-start_time)
  data = {'Districts': districts, "Education": category_dict["Education"], "Health": category_dict["Health"], "Connectivity": category_dict["Connectivity"], "Utilities": category_dict["Utilities"], "Government_Facilities": category_dict["Government_Facilities"]}
  # data = {'Districts': districts, "Education": category_dict["Education"], "Health": category_dict["Health"], "Connectivity": category_dict["Connectivity"], "Utilities": category_dict["Utilities"]}
  df = pd.DataFrame(data, columns = data.keys())
  if x == 0:
    df.to_csv(districts[0]+'/Histogram_data_of_combined_grids_for_' + '_for_nearest_'+'category'+'_distance_in_km'+'.csv', index=False)
  elif x == 1:
    df.to_csv(districts[0]+'/Histogram_data_of_rural_grids_for_' + '_for_nearest_'+'category'+'_distance_in_km'+'.csv', index=False)
  elif x == 2:
    df.to_csv(districts[0]+'/Histogram_data_of_all_grids_for_' + '_for_nearest_'+'category'+'_distance_in_km'+'.csv', index=False)

def create_box_plot_for_distribution_of_nearest_amenity_distance_in_combined_grids(district_name_list, category_name, year,x):
  distribution_list=[]
  for i in range(len(district_name_list)):
    filename = district_name_list[i] + '/' + district_name_list[i] + '_nearest_'+category_name+'_from_each_grid_centre.csv'
    grids_info=get_grid_info(district_name_list[i],year)
    num_arr=pd.read_csv(filename)
    num_arr=num_arr.to_numpy()
    num_arr = num_arr[:,1]
    filename=district_name_list[i] + '/' + district_name_list[i]+'_grid_population.csv'
    grids_info=get_grid_info(district_name_list[i],year)
    pop_arr=pd.read_csv(filename)
    pop_arr=pop_arr.to_numpy()
    mod_pop_arr = pop_arr[:,2]
    if x == 0:
      combined_grids_dist=num_arr[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
    elif x == 1:
      combined_grids_dist=num_arr[(grids_info[:,3]=='Rural')]
    elif x == 2:
      combined_grids_dist=num_arr[np.logical_and((grids_info[:,3]!='Rejected'),(mod_pop_arr==1))]
    distribution_list.append(combined_grids_dist)
  bx=plt.boxplot(distribution_list, labels=district_name_list, showfliers=False, showcaps=True, showmeans=True )
  plt.ylabel(category_name)
  if x == 0:
    plt.savefig(district_name_list[i]+'/Box_Plot_for_combined_grids_nearest_'+category_name+'amenity_site_distance_in_km.png', dpi=1000, bbox_inches='tight')
  elif x == 1:
    plt.savefig(district_name_list[i]+'/Box_Plot_for_rural_grids_nearest_'+category_name+'amenity_site_distance_in_km.png', dpi=1000, bbox_inches='tight')
  elif x == 2:
    plt.savefig(district_name_list[i]+'/Box_Plot_for_all_grids_nearest_'+category_name+'amenity_site_distance_in_km.png', dpi=1000, bbox_inches='tight')
  plt.show()

districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
category_list=["Education","Health","Connectivity","Utilities","Government_Facilities"]
districts = ['Jamui']
# category_dict = ["Education", "Health", "Connectivity","Utilities"]
for x in range(3):
  for i in range(len(category_list)):
    start_time=time.time()
    create_box_plot_for_distribution_of_nearest_amenity_distance_in_combined_grids(districts, category_list[i],2019,x)
    print('done for category '+category_list[i]+' in time ',time.time()-start_time)

# NO NEED TO RUN

# NO NEED TO RUN

def percentile_value_for_nearest_amenity_dist_for_Cz_grids(district_name,category_name,year,z):#using 80 percentile distance, z=1/2/3/4/5
  filename = district_name + '/' + district_name + '_nearest_'+category_name+'_from_each_grid_centre.csv'
  grids_info=get_grid_info(district_name,year)
  num_arr=pd.read_csv(filename)
  num_arr=num_arr.to_numpy()
  num_arr = num_arr[:,1]
  cx_grids_dist=num_arr[(grids_info[:,4]==z)]
  return_value = np.percentile(cx_grids_dist,80)
  return return_value

for k in range(5):
  districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
  mod_districts=['Bangalore','Chennai','Delhi','Gurgaon','Kolkata','Mumbai']#as Hyderabad has 0 C1 grids in 2019
  districts = ['Hardoi']
  mod_districts = ['Hardoi']
  category_dict={"Education":[],"Health":[],"Connectivity":[],"Utilities":[],"Government_Facilities":[]}
  for i in range(len(districts)):
    for key in category_dict:
      if ((k+1)==2 and i==1):#as Hyderabad has 0 C1 grids in 2019
        pass
      else:
        start_time=time.time()
        category_dict[key].append(percentile_value_for_nearest_amenity_dist_for_Cz_grids(districts[i],key,2019,(k+1)))
        print('done for district '+districts[i]+' for category '+key+' for class = '+str(k+1)+' in time ',time.time()-start_time)
  if ((k+1)==2):
    data = {'Districts': mod_districts, "Education": category_dict["Education"], "Health": category_dict["Health"], "Connectivity": category_dict["Connectivity"], "Utilities": category_dict["Utilities"], "Government_Facilities": category_dict["Government_Facilities"]}
    df = pd.DataFrame(data, columns = data.keys())
    df.to_csv(districts[0]+'/Histogram_data_of_C'+str(k+1)+'_grids_for_' + '_for_nearest_'+'category'+'_distance_in_km'+'.csv', index=False)
  else:
    data = {'Districts': districts, "Education": category_dict["Education"], "Health": category_dict["Health"], "Connectivity": category_dict["Connectivity"], "Utilities": category_dict["Utilities"], "Government_Facilities": category_dict["Government_Facilities"]}
    df = pd.DataFrame(data, columns = data.keys())
    df.to_csv(districts[0]+'/Histogram_data_of_C'+str(k+1)+'_grids_for_' + '_for_nearest_'+'category'+'_distance_in_km'+'.csv', index=False)



def create_box_plot_for_distribution_of_nearest_amenity_distance_in_Cz_grids(district_name, category_name, year):
  distribution_list=[]
  x_label=[]
  for i in range(1,6):
    filename = district_name + '/' + district_name + '_nearest_'+category_name+'_from_each_grid_centre.csv'
    grids_info=get_grid_info(district_name,year)
    num_arr=pd.read_csv(filename)
    num_arr=num_arr.to_numpy()
    num_arr = num_arr[:,1]
    cx_grids_dist=num_arr[(grids_info[:,4]==i)]
    if (len(cx_grids_dist) != 0):
      distribution_list.append(cx_grids_dist)
      x_label.append(i)
  bx=plt.boxplot(distribution_list, labels=x_label, showfliers=True, showcaps=True, showmeans=True )
  plt.ylabel(category_name)
  plt.savefig('Box_Plot_for_Cz_grids_nearest_'+category_name+'_amenity_site_distance_in_km.png', dpi=1000, bbox_inches='tight')
  plt.show()

districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
districts = ['Hardoi']
category_list=["Education","Health","Connectivity","Utilities","Government_Facilities"]
for i in range(len(districts)):
  for j in range(len(category_list)):
    start_time=time.time()
    create_box_plot_for_distribution_of_nearest_amenity_distance_in_Cz_grids(districts[i],category_list[j],2019)
    print('done for district '+districts[i]+' for category '+category_list[j]+' in time ',time.time()-start_time)

# NOW YOU CAN

# NOW YOU CAN

# def create_csv_file_for_cdf_for_combined_grids_for_num_amenities_within_std_range(district_name,amenity_type,year):
#   filename = district_name + '_num_'+amenity_type+'_within_std_range_from_each_centre_grid_'+str(year)+'.csv'
#   grids_info=get_grid_info(district_name,year)
#   num_arr=pd.read_csv(filename)
#   num_arr=num_arr.to_numpy()
#   num_arr = num_arr[:,1]
#   grid_num=np.arange(num_arr.shape[0])
#   grid_num=grid_num[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
#   combined_grids=num_arr[(np.logical_or((grids_info[:,3]=='PeriUrban'),(grids_info[:,3]=='Urban')))]
#   data = {'Grid_Number': grid_num, amenity_type: combined_grids}
#   df = pd.DataFrame(data, columns = data.keys())
#   df.to_csv('CDF_plot_data_of_combined_grids_for_'+district_name + '_for_number_of_'+amenity_type+'_within_std_range'+'.csv', index=False)

# districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
# amenities=['local_government_office','school','police','doctor','train_station','department_store','supermarket','primary_school','taxi_stand','bus_station','hospital','bank']
# for i in range(len(districts)):
#   for j in range(len(amenities)):
#     start_time=time.time()
#     create_csv_file_for_cdf_for_combined_grids_for_num_amenities_within_std_range(districts[i],amenities[j],2019)
#     print('done for district '+districts[i]+' for amenity '+amenities[j]+' in time ',time.time()-start_time)

def percentile_value_for_num_amenities_within_std_rangefor_combined_grids(district_name,category_name,year,x):#20 percentile value
  filename = district_name + '/' + district_name + '_num_'+category_name+'_within_std_range_from_each_grid_centre_'+str(year)+'.csv'
  grids_info=get_grid_info(district_name,year)
  num_arr=pd.read_csv(filename)
  num_arr=num_arr.to_numpy()
  num_arr = num_arr[:,1]
  filename=district_name + '/' + district_name+'_grid_population.csv'
  grids_info=get_grid_info(district_name,year)
  pop_arr=pd.read_csv(filename)
  pop_arr=pop_arr.to_numpy()
  mod_pop_arr = pop_arr[:,2]
  # grid_num=np.arange(num_arr.shape[0])
  # grid_num=grid_num[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
  if x == 0:
    combined_grids=num_arr[(np.logical_or((grids_info[:,3]=='PeriUrban'),(grids_info[:,3]=='Urban')))]
  elif x == 1:
    combined_grids=num_arr[(grids_info[:,3]=='Rural')]
  elif x == 2:
    combined_grids=num_arr[(np.logical_and((grids_info[:,3]!='Rejected'),(mod_pop_arr==1)))]
  return_value=int(np.percentile(combined_grids,20))
  return return_value
  # data = {'Grid_Number': grid_num, amenity_type: combined_grids}
  # df = pd.DataFrame(data, columns = data.keys())
  # df.to_csv('CDF_plot_data_of_combined_grids_for_'+district_name + '_for_number_of_'+amenity_type+'_within_std_range'+'.csv', index=False)

districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
category_dict={"Education":[],"Health":[],"Connectivity":[],"Utilities":[],"Government_Facilities":[]}
districts = ['Dhubri']
for x in range(3):
  category_dict={"Education":[],"Health":[],"Connectivity":[],"Utilities":[],"Government_Facilities":[]}
  for i in range(len(districts)):
    for key in category_dict:
      start_time=time.time()
      category_dict[key].append(percentile_value_for_num_amenities_within_std_rangefor_combined_grids(districts[i],key,2019,x))
      print('done for district '+districts[i]+' for category '+key+' in time ',time.time()-start_time)
  data = {'Districts': districts, "Education": category_dict["Education"], "Health": category_dict["Health"], "Connectivity": category_dict["Connectivity"], "Utilities": category_dict["Utilities"], "Government_Facilities": category_dict["Government_Facilities"]}
  df = pd.DataFrame(data, columns = data.keys())
  if x == 0:
    df.to_csv(districts[0]+'/Histogram_data_of_combined_grids_for_' + '_num_'+'category'+'_within_std_distance'+'.csv', index=False)
  elif x == 1:
    df.to_csv(districts[0]+'/Histogram_data_of_rural_grids_for_' + '_num_'+'category'+'_within_std_distance'+'.csv', index=False)
  elif x == 2:
    df.to_csv(districts[0]+'/Histogram_data_of_all_grids_for_' + '_num_'+'category'+'_within_std_distance'+'.csv', index=False)

def create_box_plot_for_distribution_of_num_amenities_within_std_range_in_combined_grids(district_name_list, category_name, year,x):
  distribution_list=[]
  for i in range(len(district_name_list)):
    filename = district_name_list[i] + '/' + district_name_list[i] + '_num_'+category_name+'_within_std_range_from_each_grid_centre_'+str(year)+'.csv'
    grids_info=get_grid_info(district_name_list[i],year)
    num_arr=pd.read_csv(filename)
    num_arr=num_arr.to_numpy()
    num_arr = num_arr[:,1]
    filename=district_name_list[i] + '/' + district_name_list[i]+'_grid_population.csv'
    grids_info=get_grid_info(district_name_list[i],year)
    pop_arr=pd.read_csv(filename)
    pop_arr=pop_arr.to_numpy()
    mod_pop_arr = pop_arr[:,2]
    if x == 0:
      combined_grids=num_arr[(np.logical_or((grids_info[:,3]=='PeriUrban'),(grids_info[:,3]=='Urban')))]
    elif x == 1:
      combined_grids=num_arr[(grids_info[:,3]=='Rural')]
    elif x == 2:
      combined_grids=num_arr[(np.logical_and((grids_info[:,3]!='Rejected'),(mod_pop_arr==1)))]
    distribution_list.append(combined_grids)
  bx=plt.boxplot(distribution_list, labels=district_name_list, showfliers=False, showcaps=True, showmeans=True )
  plt.ylabel(category_name)
  if x == 0:
    plt.savefig(district_name_list[i]+'/Box_Plot_for_combined_grids_num_'+category_name+'amenity_sites_within_std_range.png', dpi=1000, bbox_inches='tight')
  elif x == 1:
    plt.savefig(district_name_list[i]+'/Box_Plot_for_rural_grids_num_'+category_name+'amenity_sites_within_std_range.png', dpi=1000, bbox_inches='tight')
  elif x == 2:
    plt.savefig(district_name_list[i]+'/Box_Plot_for_all_grids_num_'+category_name+'amenity_sites_within_std_range.png', dpi=1000, bbox_inches='tight')
  plt.show()

districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
category_list=["Education","Health","Connectivity","Utilities","Government_Facilities"]
districts = ['Jamui']
for x in range(3):
  for i in range(len(category_list)):
    start_time=time.time()
    create_box_plot_for_distribution_of_num_amenities_within_std_range_in_combined_grids(districts, category_list[i],2019,x)
    print('done for category '+category_list[i]+' in time ',time.time()-start_time)

# NO NEED TO RUN

# NO NEED TO RUN

def percentile_value_for_num_amenities_within_std_range_for_Cz_grids(district_name,category_name,year,z):#20 percentile value; z=1/2/3/4/5
  filename = district_name + '/' + district_name + '_num_'+category_name+'_within_std_range_from_each_grid_centre_'+str(year)+'.csv'
  grids_info=get_grid_info(district_name,year)
  num_arr=pd.read_csv(filename)
  num_arr=num_arr.to_numpy()
  num_arr = num_arr[:,1]
  cz_grids=num_arr[(grids_info[:,4]==z)]
  return_value=int(np.percentile(cz_grids,20))
  return return_value

for k in range(5):
  districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
  mod_districts=['Bangalore','Chennai','Delhi','Gurgaon','Kolkata','Mumbai']#as Hyderabad has 0 C1 grids in 2019
  districts = ['Hardoi']
  mod_districts = ['Hardoi']
  category_dict={"Education":[],"Health":[],"Connectivity":[],"Utilities":[],"Government_Facilities":[]}
  for i in range(len(districts)):
    for key in category_dict:
      if ((k+1)==1 and i==4):#as Hyderabad has 0 C1 grids in 2019
        pass
      else:
        start_time=time.time()
        category_dict[key].append(percentile_value_for_num_amenities_within_std_range_for_Cz_grids(districts[i],key,2019,(k+1)))
        print('done for district '+districts[i]+' for category '+key+' for class = '+str(k+1)+' in time ',time.time()-start_time)
  if ((k+1)==1):
    data = {'Districts': mod_districts, "Education": category_dict["Education"], "Health": category_dict["Health"], "Connectivity": category_dict["Connectivity"], "Utilities": category_dict["Utilities"], "Government_Facilities": category_dict["Government_Facilities"]}
    df = pd.DataFrame(data, columns = data.keys())
    df.to_csv(districts[0]+'/Histogram_data_of_C'+str(k+1)+'_grids_for_' + '_for_num_'+'category'+'_within_std_distance'+'.csv', index=False)
  else:
    data = {'Districts': districts, "Education": category_dict["Education"], "Health": category_dict["Health"], "Connectivity": category_dict["Connectivity"], "Utilities": category_dict["Utilities"], "Government_Facilities": category_dict["Government_Facilities"]}
    df = pd.DataFrame(data, columns = data.keys())
    df.to_csv(districts[0]+'/Histogram_data_of_C'+str(k+1)+'_grids_for_' + '_for_num_'+'category'+'_within_std_distance'+'.csv', index=False)

def create_box_plot_for_distribution_of_num_amenities_within_std_range_in_Cz_grids(district_name, category_name, year):
  distribution_list=[]
  x_label=[]
  for i in range(1,6):
    filename = district_name + '/' + district_name + '_num_'+category_name+'_within_std_range_from_each_grid_centre_'+str(year)+'.csv'
    grids_info=get_grid_info(district_name,year)
    num_arr=pd.read_csv(filename)
    num_arr=num_arr.to_numpy()
    num_arr = num_arr[:,1]
    cx_grids=num_arr[(grids_info[:,4]==i)]
    if (len(cx_grids) != 0):
      distribution_list.append(cx_grids)
      x_label.append(i)
  bx=plt.boxplot(distribution_list, labels=x_label, showfliers=True, showcaps=True, showmeans=True )
  plt.ylabel(category_name)
  plt.savefig('Box_Plot_for_Cz_grids_num_'+category_name+'_amenity_sites_within_std_range.png', dpi=1000, bbox_inches='tight')
  plt.show()

districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
districts = ['Hardoi']
category_list=["Education","Health","Connectivity","Utilities","Government_Facilities"]
for i in range(len(districts)):
  for j in range(len(category_list)):
    start_time=time.time()
    create_box_plot_for_distribution_of_num_amenities_within_std_range_in_Cz_grids(districts[i],category_list[j],2019)
    print('done for district '+districts[i]+' for category '+category_list[j]+' in time ',time.time()-start_time)

# NOW YOU CAN


# NOW YOU CAN

# def create_csv_file_for_cdf_for_combined_grids_for_num_amenities_in_each_grid(district_name,amenity_type,year):
#   filename = district_name + '_num_'+amenity_type+'_in_each_grid'+'.csv'
#   num_arr=pd.read_csv(filename)
#   grids_info=get_grid_info(district_name,year)
#   num_arr=num_arr.to_numpy()
#   num_arr = num_arr[:,1]
#   grid_num=np.arange(num_arr.shape[0])
#   grid_num=grid_num[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
#   combined_grids=num_arr[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
#   data = {'Grid_Number': grid_num, amenity_type: combined_grids}
#   df = pd.DataFrame(data, columns = data.keys())
#   df.to_csv('CDF_plot_data_of_combined_grids_for_'+district_name + '_for_number_of_'+amenity_type+'_in_each_grid'+'.csv', index=False)

# districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
# amenities=['local_government_office','school','police','doctor','train_station','department_store','supermarket','primary_school','taxi_stand','bus_station','hospital','bank']
# for i in range(len(districts)):
#   for j in range(len(amenities)):
#     start_time=time.time()
#     create_csv_file_for_cdf_for_combined_grids_for_num_amenities_in_each_grid(districts[i],amenities[j],2019)
#     print('done for district '+districts[i]+' for amenity '+amenities[j]+' in time ',time.time()-start_time)

def percentile_value_for_num_amenities_in_grid_for_combined_grids(district_name,category_name,year,x):#20 percentile value
  filename = district_name + '/' + district_name + '_num_'+category_name+'_in_each_grid'+'.csv'
  num_arr=pd.read_csv(filename)
  grids_info=get_grid_info(district_name,year)
  num_arr=num_arr.to_numpy()
  num_arr = num_arr[:,1]
  filename=district_name + '/' + district_name+'_grid_population.csv'
  grids_info=get_grid_info(district_name,year)
  pop_arr=pd.read_csv(filename)
  pop_arr=pop_arr.to_numpy()
  mod_pop_arr = pop_arr[:,2]
  # grid_num=np.arange(num_arr.shape[0])
  # grid_num=grid_num[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
  if x == 0:
    combined_grids=num_arr[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
  elif x == 1:
    combined_grids=num_arr[(grids_info[:,3]=='Rural')]
  elif x == 2:
    combined_grids=num_arr[np.logical_and((grids_info[:,3]!='Rejected'),(mod_pop_arr==1))]
  return_value=int(np.percentile(combined_grids,20))
  return return_value
  # data = {'Grid_Number': grid_num, amenity_type: combined_grids}
  # df = pd.DataFrame(data, columns = data.keys())
  # df.to_csv('CDF_plot_data_of_combined_grids_for_'+district_name + '_for_number_of_'+amenity_type+'_in_each_grid'+'.csv', index=False)

districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
category_dict={"Education":[],"Health":[],"Connectivity":[],"Utilities":[],"Government_Facilities":[]}
districts = ['Jamui']
for x in range(3):
  category_dict={"Education":[],"Health":[],"Connectivity":[],"Utilities":[],"Government_Facilities":[]}
  for i in range(len(districts)):
    for key in category_dict:
      start_time=time.time()
      category_dict[key].append(percentile_value_for_num_amenities_in_grid_for_combined_grids(districts[i],key,2019,x))
      print('done for district '+districts[i]+' for category '+key+' in time ',time.time()-start_time)
  data = {'Districts': districts, "Education": category_dict["Education"], "Health": category_dict["Health"], "Connectivity": category_dict["Connectivity"], "Utilities": category_dict["Utilities"], "Government_Facilities": category_dict["Government_Facilities"]}
  df = pd.DataFrame(data, columns = data.keys())
  if x == 0:
    df.to_csv(districts[0]+'/Histogram_data_of_combined_grids_for_' + '_num_'+'category'+'_in_each_grid'+'.csv', index=False)
  elif x == 1:
    df.to_csv(districts[0]+'/Histogram_data_of_rural_grids_for_' + '_num_'+'category'+'_in_each_grid'+'.csv', index=False)
  elif x == 2:
    df.to_csv(districts[0]+'/Histogram_data_of_all_grids_for_' + '_num_'+'category'+'_in_each_grid'+'.csv', index=False)

# NO NEED TO RUN


# NO NEED TO RUN

def percentile_value_for_num_amenities_in_grid_for_Cz_grids(district_name,category_name,year,z):#20 percentile value; z=1/2/3/4/5
  filename = district_name + '/' + district_name + '_num_'+category_name+'_in_each_grid'+'.csv'
  num_arr=pd.read_csv(filename)
  grids_info=get_grid_info(district_name,year)
  num_arr=num_arr.to_numpy()
  num_arr = num_arr[:,1]
  cz_grids=num_arr[(grids_info[:,4]==z)]
  return_value=int(np.percentile(cz_grids,20))
  return return_value

for k in range(5):
  districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
  mod_districts=['Bangalore','Chennai','Delhi','Gurgaon','Kolkata','Mumbai']#as Hyderabad has 0 C1 grids in 2019
  districts = ['Hardoi']
  mod_districts = ['Hardoi']
  category_dict={"Education":[],"Health":[],"Connectivity":[],"Utilities":[],"Government_Facilities":[]}
  for i in range(len(districts)):
    for key in category_dict:
      if ((k+1)==1 and i==4):#as Hyderabad has 0 C1 grids in 2019
        pass
      else:
        start_time=time.time()
        category_dict[key].append(percentile_value_for_num_amenities_in_grid_for_Cz_grids(districts[i],key,2019,(k+1)))
        print('done for district '+districts[i]+' for category '+key+' for class = '+str(k+1)+' in time ',time.time()-start_time)
  if ((k+1)==1):
    data = {'Districts': mod_districts, "Education": category_dict["Education"], "Health": category_dict["Health"], "Connectivity": category_dict["Connectivity"], "Utilities": category_dict["Utilities"], "Government_Facilities": category_dict["Government_Facilities"]}
    df = pd.DataFrame(data, columns = data.keys())
    df.to_csv(districts[0]+'/Histogram_data_of_C'+str(k+1)+'_grids_for_' + '_for_num_'+'category'+'_in_each_grid'+'.csv', index=False)
  else:
    data = {'Districts': districts, "Education": category_dict["Education"], "Health": category_dict["Health"], "Connectivity": category_dict["Connectivity"], "Utilities": category_dict["Utilities"], "Government_Facilities": category_dict["Government_Facilities"]}
    df = pd.DataFrame(data, columns = data.keys())
    df.to_csv(districts[0]+'/Histogram_data_of_C'+str(k+1)+'_grids_for_' + '_for_num_'+'category'+'_in_each_grid'+'.csv', index=False)

# amenities = ['primary_school', 'train_station', 'department_store', 'supermarket', 'bank', 'school', 'police', 'doctor', 'hospital', 'local_government_office', 'taxi_stand', 'bus_station']
# bboxes = {'Bangalore': (12.64, 13.23, 77.32, 77.83), 'Chennai': (12.95, 13.14, 80.16, 80.31), 'Delhi': (28.40, 28.89, 76.83, 77.34), 'Gurgaon': (28.20, 28.55, 76.63, 77.24), 'Hyderabad': (17.29, 17.48, 78.38, 78.54), 'Kolkata': (22.49, 22.63, 88.27, 88.41), 'Mumbai': (18.89, 19.27, 72.77, 72.99)}

# # indicators = [('_for_nearest_', '_distance_in_km'), ('_for_number_of_', '_in_each_grid'), ('_for_number_of_', '_within_std_range')]
# indicators = [('_for_nearest_', '_distance_in_km')]
# bboxes = {'Delhi': (28.40, 28.89, 76.83, 77.34)}
# amenities = ['school', 'hospital', 'police', 'bank']
# prefix = 'CDF_plot_data_of_combined_grids_for_'
# for indicator in indicators:
#     for district in bboxes.keys():
#         dfs = []
#         for amenity in amenities:
#             # CDF_plot_data_of_combined_grids_for_Bangalore_for_nearest_bank_distance_in_km
#             csv_file = 'CDF_plot_data_of_combined_grids_for_' + district + '_for_nearest_'+ amenity + '_distance_in_km' + '.csv'
#             data = pd.read_csv(csv_file)
#             dfs.append(data[amenity].to_numpy())
#         # res = pd.concat(dfs, axis=1)
#         # ax = res.plot.box()
#         fig = plt.figure() 

#         # Creating axes instance 
#         ax = fig.add_axes([0, 0, 1, 1]) 
        
#         ax.set_ylim(-0.1,2.5)
#         # Creating plot 
#         bp = ax.boxplot(dfs, labels = amenities) 
#         fig.savefig('boxplot.jpg')
#         # show plot 
#         plt.show()
# wsor=np.array((bp['fliers'][0].get_data()[1]))
# sch=np.array(dfs[0].astype('float'))
# # print(wsor)
# # print(sch)
# index=np.in1d(sch,wsor)

# #looking at outliers
# school_out_liers=np.array((bp['fliers'][0].get_data()[1]))#0 for school
# school_all=np.array(dfs[0].astype('float'))#0 for school
# # print(wsor)
# # print(sch)
# school_index=np.in1d(school_all,school_out_liers)
# school_csv_file = 'CDF_plot_data_of_combined_grids_for_' + 'Delhi' + '_for_nearest_'+ 'school' + '_distance_in_km' + '.csv'
# school_data = pd.read_csv(school_csv_file)
# school_outlying_grids=school_data['Grid_Number'].to_numpy()[school_index]
# print('grid number of outliers in boxplot for school',school_outlying_grids)
# school_grids_info=get_grid_info('Delhi',2019)
# school_outlying_grid_class=school_grids_info[:,4][school_outlying_grids]
# print('grid class of outliers in boxplot for school',school_outlying_grid_class)
# school_outlying_lat_lon=school_grids_info[:,1:3][school_outlying_grids]
# print('lat lon of school outliers',school_outlying_lat_lon)
# school_grids_info[:,3][school_outlying_grids]

# hospital_out_liers=np.array((bp['fliers'][1].get_data()[1]))#1 for hospital
# hospital_all=np.array(dfs[1].astype('float'))#1 for hospital
# # print(wsor)
# # print(sch)
# hospital_index=np.in1d(hospital_all,hospital_out_liers)
# hospital_csv_file = 'CDF_plot_data_of_combined_grids_for_' + 'Delhi' + '_for_nearest_'+ 'hospital' + '_distance_in_km' + '.csv'
# hospital_data = pd.read_csv(hospital_csv_file)
# hospital_outlying_grids=hospital_data['Grid_Number'].to_numpy()[hospital_index]
# print('grid number of outliers in boxplot for hospital',hospital_outlying_grids)
# hospital_grids_info=get_grid_info('Delhi',2019)
# hospital_outlying_grid_class=hospital_grids_info[:,4][hospital_outlying_grids]
# print('grid class of outliers in boxplot for hospital',hospital_outlying_grid_class)
# hospital_outlying_lat_lon=hospital_grids_info[:,1:3][hospital_outlying_grids]
# print('lat lon of hospital outliers',hospital_outlying_lat_lon)
# hospital_grids_info[:,3][hospital_outlying_grids]

# def outliers_grid_number_for_nearest_amenity_indicator(district_name,category_name,year):
#   filename = district_name + '_nearest_'+category_name+'_from_each_grid_centre.csv'
#   grids_info=get_grid_info(district_name,year)
#   num_arr=pd.read_csv(filename)
#   num_arr=num_arr.to_numpy()
#   num_arr = num_arr[:,1] 
#   grid_num=np.arange(num_arr.shape[0])
#   combined_grid_num=grid_num[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
#   combined_grids_dist=num_arr[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
#   fig = plt.figure(figsize =(10, 7)) 
#   # Creating plot
#   bp=plt.boxplot(combined_grids_dist, labels=[category_name])
#   # show plot 
#   plt.show()
#   amenity_outlier=(np.array(bp['fliers'][0].get_data()[1]))
#   # print(amenity_outlier)
#   amenity_index=np.in1d(combined_grids_dist,amenity_outlier)
#   # print(amenity_index)
#   outlier_grid_numbers=combined_grid_num[amenity_index]
#   # print(outlier_grid_numbers)
#   return outlier_grid_numbers

# districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
# category_dict={"Education":[],"Health":[],"Connectivity":[],"Utilities":[],"Government_Facilities":[]}
# for i in range(len(districts)):
#   for key in category_dict:
#     start_time=time.time()
#     category_dict[key].append(len(outliers_grid_number_for_nearest_amenity_indicator(districts[i],key,2019)))
#     print('done for district '+districts[i]+' for category '+key+' in time ',time.time()-start_time)
# data = {'Districts': districts, "Education": category_dict["Education"], "Health": category_dict["Health"], "Connectivity": category_dict["Connectivity"], "Utilities": category_dict["Utilities"], "Government_Facilities": category_dict["Government_Facilities"]}
# df = pd.DataFrame(data, columns = data.keys())
# df.to_csv('Histogram_data_of_combined_grids_for_' + 'num_of_outliers_for_nearest_'+'category'+'_distance'+'.csv', index=False)

# districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
# category_dict={"Education":[],"Health":[],"Connectivity":[],"Utilities":[],"Government_Facilities":[]}
# for i in range(len(districts)):
#   for key in category_dict:
#     start_time=time.time()
#     district_name=districts[i]
#     category_name=key
#     year=2019
#     filename = district_name + '_nearest_'+category_name+'_from_each_grid_centre.csv'
#     grids_info=get_grid_info(district_name,year)
#     num_arr=pd.read_csv(filename)
#     num_arr=num_arr.to_numpy()
#     num_arr = num_arr[:,1] 
#     grid_num=np.arange(num_arr.shape[0])
#     combined_grid_num=grid_num[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
#     combined_grids_dist=num_arr[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
#     fig = plt.figure(figsize =(10, 7)) 
#     # Creating plot
#     bp=plt.boxplot(combined_grids_dist, labels=[category_name])
#     # show plot 
#     plt.show()
#     amenity_outlier=(np.array(bp['fliers'][0].get_data()[1]))
#     # print(amenity_outlier)
#     amenity_index=np.in1d(combined_grids_dist,amenity_outlier)
#     # print(amenity_index)
#     outlier_grid_numbers=combined_grid_num[amenity_index]
#     # print(outlier_grid_numbers)
#     # print(amenity_outlier)
#     outliers_lat_lon=grids_info[:,1:3][outlier_grid_numbers]
#     # print(outliers_lat_lon)
#     if (len(amenity_outlier)==0):
#       pass
#     else:
#       imp_lat_lon=outliers_lat_lon[np.argmax(amenity_outlier)]
#       print('done for district '+districts[i]+' for category '+key+' lat-lon=> ', imp_lat_lon)

# NOW YOU CAN

# NOW YOU CAN

def outliers_grid_percentage_for_nearest_amenity_indicator(district_name,category_name,year,x):
  filename = district_name + '/' + district_name + '_nearest_'+category_name+'_from_each_grid_centre.csv'
  grids_info=get_grid_info(district_name,year)
  num_arr=pd.read_csv(filename)
  num_arr=num_arr.to_numpy()
  num_arr = num_arr[:,1] 
  filename=district_name + '/' + district_name+'_grid_population.csv'
  grids_info=get_grid_info(district_name,year)
  pop_arr=pd.read_csv(filename)
  pop_arr=pop_arr.to_numpy()
  mod_pop_arr = pop_arr[:,2]
  grid_num=np.arange(num_arr.shape[0])
  if x == 0:
    combined_grid_num=grid_num[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
    combined_grids_dist=num_arr[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
  elif x == 1:
    combined_grid_num=grid_num[(grids_info[:,3]=='Rural')]
    combined_grids_dist=num_arr[(grids_info[:,3]=='Rural')]
  elif x == 2:
    combined_grid_num=grid_num[np.logical_and((grids_info[:,3]!='Rejected'),(mod_pop_arr==1))]
    combined_grids_dist=num_arr[np.logical_and((grids_info[:,3]!='Rejected'),(mod_pop_arr==1))]
  fig = plt.figure(figsize =(10, 7)) 
  # Creating plot
  bp=plt.boxplot(combined_grids_dist, labels=[category_name])
  # show plot 
  plt.show()
  amenity_outlier=(np.array(bp['fliers'][0].get_data()[1]))
  # print(amenity_outlier)
  amenity_index=np.in1d(combined_grids_dist,amenity_outlier)
  # print(amenity_index)
  outlier_grid_numbers=combined_grid_num[amenity_index]
  outlier_grid_percentage=(len(outlier_grid_numbers)/len(combined_grid_num))*(100)
  # print(outlier_grid_numbers)
  return outlier_grid_percentage

districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
category_dict={"Education":[],"Health":[],"Connectivity":[],"Utilities":[],"Government_Facilities":[]}
districts = ['Jamui']
for x in range(3):
  category_dict={"Education":[],"Health":[],"Connectivity":[],"Utilities":[],"Government_Facilities":[]}
  for i in range(len(districts)):
    for key in category_dict:
      start_time=time.time()
      category_dict[key].append(outliers_grid_percentage_for_nearest_amenity_indicator(districts[i],key,2019,x))
      print('done for district '+districts[i]+' for category '+key+' in time ',time.time()-start_time)
  data = {'Districts': districts, "Education": category_dict["Education"], "Health": category_dict["Health"], "Connectivity": category_dict["Connectivity"], "Utilities": category_dict["Utilities"], "Government_Facilities": category_dict["Government_Facilities"]}
  df = pd.DataFrame(data, columns = data.keys())
  if x == 0:
    df.to_csv(districts[0]+'/Histogram_data_of_combined_grids_for_' + 'percentage_of_outlier_grids_for_nearest_'+'category'+'_distance'+'.csv', index=False)
  elif x == 1:
    df.to_csv(districts[0]+'/Histogram_data_of_rural_grids_for_' + 'percentage_of_outlier_grids_for_nearest_'+'category'+'_distance'+'.csv', index=False)
  elif x == 2:
    df.to_csv(districts[0]+'/Histogram_data_of_all_grids_for_' + 'percentage_of_outlier_grids_for_nearest_'+'category'+'_distance'+'.csv', index=False)







# NO NEED TO RUN


# NO NEED TO RUN

def outliers_cx_grid_count_list_for_nearest_amenity_indicator(district_name,category_name,year):
  filename = district_name + '/' + district_name + '_nearest_'+category_name+'_from_each_grid_centre.csv'
  grids_info=get_grid_info(district_name,year)
  num_arr=pd.read_csv(filename)
  num_arr=num_arr.to_numpy()
  num_arr = num_arr[:,1] 
  
  grid_num=np.arange(num_arr.shape[0])
  combined_grid_num=grid_num[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
  combined_grids_dist=num_arr[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
  fig = plt.figure(figsize =(10, 7)) 
  # Creating plot
  bp=plt.boxplot(combined_grids_dist, labels=[category_name], showfliers=True, showcaps=True, showmeans=True)
  # show plot 
  plt.show()
  amenity_outlier=(np.array(bp['fliers'][0].get_data()[1]))
  # print(amenity_outlier)
  amenity_index=np.in1d(combined_grids_dist,amenity_outlier)
  # print(amenity_index)
  outlier_grid_numbers=combined_grid_num[amenity_index]
  # print(outlier_grid_numbers)
  cx_list=[0,0,0,0,0]
  for i in range(len(outlier_grid_numbers)):
    cx_list_index=int(grids_info[outlier_grid_numbers[i],4]-1)
    # print(i,cx_list_index)
    # if (grids_info[outlier_grid_numbers[i],4]==4 or grids_info[outlier_grid_numbers[i],4]==5):
    #   print(district_name, ' ', category_name, " threshold distance=>", bp['caps'][1].get_ydata()[0], ' outlier_distance-->', num_arr[outlier_grid_numbers[i]] , 'lat-lon==>', grids_info[outlier_grid_numbers[i],1],' ', grids_info[outlier_grid_numbers[i],2] , ' outlier_grid_number-->', outlier_grid_numbers[i], ' grid_class-->', grids_info[outlier_grid_numbers[i],4])
    cx_list[cx_list_index]=cx_list[(cx_list_index)]+1
  return cx_list

districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
districts = ['Hardoi']
class_type=['C1','C2','C3','C4','C5']
for i in range(len(districts)):
  category_dict={"Education":[],"Health":[],"Connectivity":[],"Utilities":[],"Government_Facilities":[]}
  for key in category_dict:
    start_time=time.time()
    category_dict[key]=category_dict[key]+outliers_cx_grid_count_list_for_nearest_amenity_indicator(districts[i],key,2019)
    print('done for district '+districts[i]+' for category '+key+' in time ',time.time()-start_time)
  data = {'Class': class_type, "Education": category_dict["Education"], "Health": category_dict["Health"], "Connectivity": category_dict["Connectivity"], "Utilities": category_dict["Utilities"], "Government_Facilities": category_dict["Government_Facilities"]}
  df = pd.DataFrame(data, columns = data.keys())
  df.to_csv(districts[0]+'/Histogram_data_of_cx_grids_for_' + districts[i]+'for_num_of_outlier_grids_for_nearest_'+'category'+'_distance'+'.csv', index=False)





def Cx_grids_count(district_name, year):
  grid_info=get_grid_info(district_name,year)
  num_combined_grids=np.sum(np.logical_or(grid_info[:,3]=='Urban',grid_info[:,3]=='PeriUrban'))
  # print(num_combined_grids)
  num_C1_grids=np.sum(grid_info[:,4]==1)
  # print(num_C1_grids)
  num_C2_grids=np.sum(grid_info[:,4]==2)
  # print(num_C2_grids)
  num_C3_grids=np.sum(grid_info[:,4]==3)
  num_C4_grids=np.sum(grid_info[:,4]==4)
  num_C5_grids=np.sum(grid_info[:,4]==5)
  return (num_C1_grids,num_C2_grids,num_C3_grids,num_C4_grids,num_C5_grids)

districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
districts = ['Hardoi']
C1_grids_count=[]
C2_grids_count=[]
C3_grids_count=[]
C4_grids_count=[]
C5_grids_count=[]
for i in range(len(districts)):
  start_time=time.time()
  (C1_count,C2_count,C3_count,C4_count,C5_count)=Cx_grids_count(districts[i],2019)
  C1_grids_count.append(C1_count)
  C2_grids_count.append(C2_count)
  C3_grids_count.append(C3_count)
  C4_grids_count.append(C4_count)
  C5_grids_count.append(C5_count)
  print('done for district '+districts[i]+' in time ',time.time()-start_time)
data = {'Districts': districts, "C1_grids_count": C1_grids_count, "C2_grids_count": C2_grids_count, "C3_grids_count": C3_grids_count, "C4_grids_count": C4_grids_count, "C5_grids_count": C5_grids_count}
df = pd.DataFrame(data, columns = data.keys())
df.to_csv(districts[0]+'/Histogram_data_of_' + 'count_of_Cx_grids_in_combined_grids'+'.csv', index=False)

def percentile_value_for_num_amenities_within_std_range_for_Cz_grids(district_name,category_name,year,z):#20 percentile value; z=1/2/3/4/5
  filename = district_name + '/' + district_name + '_num_'+category_name+'_within_std_range_from_each_grid_centre_2019.csv'
  num_arr=pd.read_csv(filename)
  grids_info=get_grid_info(district_name,year)
  num_arr=num_arr.to_numpy()
  num_arr = num_arr[:,1]
  cz_grids=num_arr[(grids_info[:,4]==z)]
  return_value=int(np.percentile(cz_grids,20))
  return return_value

# for z in range(1,6,1):
#   print(z)

districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
districts = ['Hardoi']
class_type=['C1','C2','C3','C4','C5']
# mod_class_type=['C1']
mod_class_type=['C1','C2','C3','C4','C5']
for i in range(len(districts)):
  if (i==0):
    category_dict={"Education":[],"Health":[],"Connectivity":[],"Utilities":[],"Government_Facilities":[]}
    for key in category_dict:
      start_time=time.time()
      for z in range(1,6,1):
        category_dict[key]=category_dict[key]+[percentile_value_for_num_amenities_within_std_range_for_Cz_grids(districts[i],key,2019,z)]
      print('done for district '+districts[i]+' for category '+key+' in time ',time.time()-start_time)
    data = {'Class': mod_class_type, "Education": category_dict["Education"], "Health": category_dict["Health"], "Connectivity": category_dict["Connectivity"], "Utilities": category_dict["Utilities"], "Government_Facilities": category_dict["Government_Facilities"]}
    df = pd.DataFrame(data, columns = data.keys())
    df.to_csv(districts[0]+'/Histogram_data_of_cx_grids_for_' + districts[i]+'_for_num_of_amenities_within_std_range'+'.csv', index=False)
  else:
    category_dict={"Education":[],"Health":[],"Connectivity":[],"Utilities":[],"Government_Facilities":[]}
    for key in category_dict:
      start_time=time.time()
      for z in range(1,6,1):
        category_dict[key]=category_dict[key]+[percentile_value_for_num_amenities_within_std_range_for_Cz_grids(districts[i],key,2019,z)]
      print('done for district '+districts[i]+' for category '+key+' in time ',time.time()-start_time)
    data = {'Class': class_type, "Education": category_dict["Education"], "Health": category_dict["Health"], "Connectivity": category_dict["Connectivity"], "Utilities": category_dict["Utilities"], "Government_Facilities": category_dict["Government_Facilities"]}
    df = pd.DataFrame(data, columns = data.keys())
    df.to_csv(districts[0]+'/Histogram_data_of_cx_grids_for_' + districts[i]+'_for_num_of_amenities_within_std_range'+'.csv', index=False)

# NOW. YOU CAN

# NOW. YOU CAN

def gini(x):
    # Mean absolute difference
    mad = np.abs(np.subtract.outer(x, x)).mean()
    # Relative mean absolute difference
    rmad = mad/np.mean(x)
    # Gini coefficient
    g = 0.5 * rmad
    return g





def calc_gini_index_for_nearest_amenity_distance_in_combined_grids(district_name,category_name,year,x):
  filename = district_name + '/' + district_name + '_nearest_'+category_name+'_from_each_grid_centre.csv'
  grids_info=get_grid_info(district_name,year)
  num_arr=pd.read_csv(filename)
  num_arr=num_arr.to_numpy()
  num_arr = num_arr[:,1] 
  filename=district_name + '/' + district_name+'_grid_population.csv'
  grids_info=get_grid_info(district_name,year)
  pop_arr=pd.read_csv(filename)
  pop_arr=pop_arr.to_numpy()
  mod_pop_arr = pop_arr[:,2]
  # grid_num=np.arange(num_arr.shape[0])
  # grid_num=grid_num[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
  if x == 0:
    combined_grids_dist=num_arr[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
  elif x == 1:
    combined_grids_dist=num_arr[(grids_info[:,3]=='Rural')]
  elif x == 2:
    combined_grids_dist=num_arr[np.logical_and((grids_info[:,3]!='Rejected'),(mod_pop_arr==1))]
  return gini(combined_grids_dist)

districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
category_dict={"Education":[],"Health":[],"Connectivity":[],"Utilities":[],"Government_Facilities":[]}
districts = ['Jamui']
for x in range(3):
  category_dict={"Education":[],"Health":[],"Connectivity":[],"Utilities":[],"Government_Facilities":[]}
  for i in range(len(districts)):
    for key in category_dict:
      start_time=time.time()
      category_dict[key].append(calc_gini_index_for_nearest_amenity_distance_in_combined_grids(districts[i],key,2019,x))
      print('done for district '+districts[i]+' for category '+key+' in time ',time.time()-start_time)
  data = {'Districts': districts, "Education": category_dict["Education"], "Health": category_dict["Health"], "Connectivity": category_dict["Connectivity"], "Utilities": category_dict["Utilities"], "Government_Facilities": category_dict["Government_Facilities"]}
  df = pd.DataFrame(data, columns = data.keys())
  if x == 0:
    df.to_csv(districts[0]+'/Histogram_data_for_gini_index_of' + '_nearest_'+'category'+'_distance_in_combined_grids_'+'.csv', index=False)
  elif x == 1:
    df.to_csv(districts[0]+'/Histogram_data_for_gini_index_of' + '_nearest_'+'category'+'_distance_in_rural_grids_'+'.csv', index=False)
  elif x == 2:
    df.to_csv(districts[0]+'/Histogram_data_for_gini_index_of' + '_nearest_'+'category'+'_distance_in_all_grids_'+'.csv', index=False)

def calc_gini_index_for_num_amenities_within_std_range_for_combined_grids(district_name,category_name,year,x):#20 percentile value
  filename = district_name + '/' + district_name + '_num_'+category_name+'_within_std_range_from_each_grid_centre_'+str(year)+'.csv'
  grids_info=get_grid_info(district_name,year)
  num_arr=pd.read_csv(filename)
  num_arr=num_arr.to_numpy()
  num_arr = num_arr[:,1]
  filename=district_name + '/' + district_name+'_grid_population.csv'
  grids_info=get_grid_info(district_name,year)
  pop_arr=pd.read_csv(filename)
  pop_arr=pop_arr.to_numpy()
  mod_pop_arr = pop_arr[:,2]
  # grid_num=np.arange(num_arr.shape[0])
  # grid_num=grid_num[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
  # combined_grids=num_arr[(np.logical_or((grids_info[:,3]=='PeriUrban'),(grids_info[:,3]=='Urban')))]
  if x == 0:
    combined_grids=num_arr[np.logical_or((grids_info[:,3]=='Urban'),(grids_info[:,3]=='PeriUrban'))]
  elif x == 1:
    combined_grids=num_arr[(grids_info[:,3]=='Rural')]
  elif x == 2:
    combined_grids=num_arr[np.logical_and((grids_info[:,3]!='Rejected'),(mod_pop_arr==1))]
  return_value=gini(combined_grids)
  return return_value

districts=['Bangalore','Chennai','Delhi','Gurgaon','Hyderabad','Kolkata','Mumbai']
category_dict={"Education":[],"Health":[],"Connectivity":[],"Utilities":[],"Government_Facilities":[]}
districts = ['Jamui']
for x in range(3):
  category_dict={"Education":[],"Health":[],"Connectivity":[],"Utilities":[],"Government_Facilities":[]}
  for i in range(len(districts)):
    for key in category_dict:
      start_time=time.time()
      category_dict[key].append(calc_gini_index_for_num_amenities_within_std_range_for_combined_grids(districts[i],key,2019,x))
      print('done for district '+districts[i]+' for category '+key+' in time ',time.time()-start_time)
  data = {'Districts': districts, "Education": category_dict["Education"], "Health": category_dict["Health"], "Connectivity": category_dict["Connectivity"], "Utilities": category_dict["Utilities"], "Government_Facilities": category_dict["Government_Facilities"]}
  df = pd.DataFrame(data, columns = data.keys())
  if x == 0:
    df.to_csv(districts[0]+'/Histogram_data_for_gini_index_of' + '_num_'+'category'+'_within_std_range_for_combined_grids'+'.csv', index=False)
  elif x == 1:
    df.to_csv(districts[0]+'/Histogram_data_for_gini_index_of' + '_num_'+'category'+'_within_std_range_for_rural_grids'+'.csv', index=False)
  elif x == 2:
    df.to_csv(districts[0]+'/Histogram_data_for_gini_index_of' + '_num_'+'category'+'_within_std_range_for_all_grids'+'.csv', index=False)

