# -*- coding: utf-8 -*-
"""1_final_classification_processing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ihl72tC-OknLXuFJXfTvtqTdwYuSQcmC
"""

from google.colab import drive #to retrieve data from drive
drive.mount('/content/drive/')

cd 'drive/My Drive/Data/OSM'

!pip install Pillow

# import all required packages
from PIL import Image
import math
from scipy import misc
from scipy import ndimage
import pandas as pd
import unittest
import os, sys
import shutil #for copying files
import numpy as np
import tqdm as tqdm
# from methods_rules_based_approach import *
# from methods_temporal_correction import *

Background=0
Greenery=1
Water=2
BuiltUp=3
BareLand=4

#fun to count occurence of x in list
def counter(x,listx):
    listx=np.asarray(listx)
    return(np.where(listx==x)[0].shape[0])

#fun to check pattern of inconsistency
def patterndetected(pixelVals):

    # find the first time a pixel was detected as Builtup
    for i in range(len(pixelVals)):
        if pixelVals[i] == BuiltUp :
            BuiltUpfirstindex = i
            break

    if (BuiltUp in pixelVals) and (not all(val==BuiltUp for val in pixelVals[BuiltUpfirstindex:])):
        #inconsistencies including Builtup pixels
        if(Greenery in pixelVals) and (Water in pixelVals) and (BareLand in pixelVals):
            return 1   #all classes present
        if(Greenery in pixelVals) and (Water in pixelVals):
            return 2
        if(Water in pixelVals) and (BareLand in pixelVals):
            return 3
        if(Greenery in pixelVals) and (BareLand in pixelVals):
            return 4
        if(Greenery in pixelVals):
            return 5
        if(Water in pixelVals):
            return 6
        if(BareLand in pixelVals):
            return 7

    #now either the pixelval doen't contain anu BuiltUp pixel so we need to check for inconsistencies within Non Built Up classes or pixel Val is consistent in respect to BuiltUp class so
    #we need to check for non builtup inconsistencies which could happen before encountering first builtup pixel.

    #inconsistencies within NBU classes
    if(Greenery in pixelVals) and (Water in pixelVals) and (BareLand not in pixelVals):
        return 8
    if(Water in pixelVals) and (BareLand in pixelVals) and (Greenery not in pixelVals):
        return 9

    return 0 #consistent

#defining correction methods for different pattern of inconsistencies
#method names defined upon the pixel values present in pixelVals
#1 denotes greenery, 2 denotes water, 3 denotes BuiltUp, 4 denotes Bareland

def pattern1234(pixelVals):
    bucount=counter(BuiltUp,pixelVals)
    if(counter(Greenery,pixelVals)>=counter(Water,pixelVals)):
        return [Greenery for i in pixelVals]
    else:
        return [Water for i in pixelVals]

def pattern123(pixelVals):
    return pattern1234(pixelVals)

def pattern234(pixelVals):
    bucount=counter(BuiltUp,pixelVals)
    if(counter(Water,pixelVals)>=bucount) and (counter(Water,pixelVals)>=counter(BareLand,pixelVals)):
        return [Water for i in pixelVals]
    if(counter(BareLand,pixelVals)>=bucount):
        return [BareLand for i in pixelVals]
    return [BuiltUp for i in pixelVals]

def pattern134(pixelVals):
    if(counter(BuiltUp,pixelVals)+counter(BareLand,pixelVals)<=counter(Greenery,pixelVals)):
        return [Greenery for i in pixelVals]
    return [BareLand for i in pixelVals]

def pattern13(pixelVals,i,j,dataset):
    if(counter(BuiltUp,pixelVals)>=counter(Greenery,pixelVals)):
        return [BuiltUp for i in pixelVals]
    dims=dataset[0].shape
    BuAreaCounts=0
    for k in range(len(pixelVals)):
        BUcount=0
        TotCount=0
        for row in range(i-2,i+3):
            if (row<0) or (row>=dims[0]):
                continue
            for col in range(j-2,j+3):
                if (col<0) or (col>=dims[1]):
                    continue
                if(dataset[k][row][col]==Background):
                    continue
                TotCount+=1
                if(dataset[k][row][col]==BuiltUp):
                    BUcount+=1
        if(BUcount>=0.5*TotCount):
            BuAreaCounts+=1
    if(BuAreaCounts>0.5*len(pixelVals)):
        return [BuiltUp for i in pixelVals]
    return [Greenery for i in pixelVals]
        

def pattern23(pixelVals):
    if(counter(Water,pixelVals)<=0.25*len(pixelVals)):
        return [BuiltUp for i in pixelVals]
    else:
        return [Water for i in pixelVals]


def pattern34(pixelVals):
    for i in range(len(pixelVals)):
        if pixelVals[i] == BuiltUp :
            BuiltUpfirstindex = i
            break
    if(counter(BuiltUp,pixelVals)>0.5*(len(pixelVals)-BuiltUpfirstindex)):
        return pixelVals[:BuiltUpfirstindex]+[BuiltUp for i in pixelVals[BuiltUpfirstindex:]]
    return [BareLand for i in pixelVals]

def pattern12_3(pixelVals):
    #since there are two possiblities with respect to the presence of BuiltUp class pixel, we need to find the index upto which we need to apply correction method
    correction_end_index=len(pixelVals)
    for i in range(len(pixelVals)):
        if pixelVals[i] == BuiltUp :
            correction_end_index = i
            break
    majority=Greenery if counter(Greenery,pixelVals)>=counter(Water,pixelVals) else Water
    return [majority for i in pixelVals[:correction_end_index]]+pixelVals[correction_end_index:]

    
def pattern24_3(pixelVals):
    #since there are two possiblities with respect to the presence of BuiltUp class pixel, we need to find the index upto which we need to apply correction method
    correction_end_index=len(pixelVals)
    for i in range(len(pixelVals)):
        if pixelVals[i] == BuiltUp :
            correction_end_index = i
            break
    majority=BareLand if counter(BareLand,pixelVals)>=counter(Water,pixelVals) else Water
    return [majority for i in pixelVals[:correction_end_index]]+pixelVals[correction_end_index:]




# for example - year_list = ['2014','2015', '2016','2017','2018','2019']

def TempCorrection(input_folder,district_name,yearlist,input_subfolder):
    os.makedirs(input_folder+"/results/" + input_subfolder+'_temp_corrected',exist_ok=True)    
    dataset = [ np.array(Image.open(input_folder+'/results/'+input_subfolder+'/'+district_name+'_prediction_'+str(i)+'.png')) for i in yearlist]   #read all images

	# verify all images have same number of background pixels
    backgroundPixels = np.unique(dataset[0],return_counts=True)[1][0]
    if not all(np.unique(dataset[k],return_counts=True)[1][0]==backgroundPixels for k in range(len(dataset))):
	    print('''
	    	Alert: inconsistency in number of background pixels across years.
	    	Temporal correction is being done with these inconsistencies.
	    	''')
	    #raise SystemExit


    dims=dataset[0].shape
    patterns=[]

    for i in tqdm.tqdm(range(dims[0]),desc='Progress: '):
        for j in range(dims[1]):
            if(dataset[0][i][j]==0):
                continue
            pixelVals=[dataset[k][i][j] for k in range(len(dataset))]  #transformation from seperate images to seperate list of values of each pixel across years.
            pattern=patterndetected(pixelVals)
            patterns.append(pattern)

	        # callind relevant inconsistency correction method
            if pattern==0:
                newPixelVals=pixelVals
            elif pattern==1:
                newPixelVals=pattern1234(pixelVals)
            elif pattern==2:
                newPixelVals=pattern123(pixelVals)
            elif pattern==3:
                newPixelVals=pattern234(pixelVals)
            elif pattern==4:
                newPixelVals=pattern134(pixelVals)
            elif pattern==5:
                newPixelVals=pattern13(pixelVals,i,j,dataset)
            elif pattern==6:
                newPixelVals=pattern23(pixelVals)
            elif pattern==7:
                newPixelVals=pattern34(pixelVals)
            elif pattern==8:
                newPixelVals=pattern12_3(pixelVals)
            else:
	            newPixelVals=pattern24_3(pixelVals)

	        # set corrected values over the dataset
            for k in range(len(newPixelVals)):
                dataset[k][i][j] = newPixelVals[k]

	# finding the percentage of incorrect 
    patterns=np.asarray(patterns)
    counts=np.unique(patterns,return_counts=True)[1]
    correct=counts[0]
    incorrect=sum(counts[1:])
    incorrect_percent=incorrect*100/(correct+incorrect)
    print("incorrect percentage= ",incorrect_percent)


	
	# storing corrected images
    for i in range(len(yearlist)):
        dataset[i] = (Image.fromarray(dataset[i])).convert("L")
        print("temp corected "+str(i)+" - ",np.unique(dataset[i],return_counts=True))
        dataset[i].save(input_folder+"/results/" + input_subfolder+'_temp_corrected/'+district_name+'_prediction_'+str(yearlist[i])+'.png')


def TempCorrection_execution(input_folder,district_name,yearlist_complete,batch_size):
    year_dict={}
    if(len(yearlist_complete)>batch_size):
        no_of_sublist = len(yearlist_complete) // batch_size
        if ((len(yearlist_complete) % batch_size))<=batch_size/2:
            no_of_sublist = no_of_sublist
        else:
            no_of_sublist = no_of_sublist + 1
    else:
        no_of_sublist = 1           

    x=0
    for i in range(no_of_sublist):
        start = x
        finish = start+batch_size
        if finish+batch_size-int(batch_size/2)>=len(yearlist_complete):
            finish=len(yearlist_complete)
        x=x+batch_size
        year_dict['yearlist'+str(i)]=yearlist_complete[start:finish]
    
    #temp_correction_list=['combined_yearly_prediction','direct_application']
    temp_correction_list=['combined_yearly_prediction']
    for i in temp_correction_list:
        print('Temporal correction for ',i)
        for x, y in year_dict.items():
            TempCorrection(input_folder,district_name,y,i)

def Overlapping_TempCorrection_execution(input_folder,district_name,yearlist_complete,temp_correction_list,batch_size):
    year_dict={}
    if(len(yearlist_complete)>batch_size):
    	extra = len(yearlist_complete)//batch_size 
    	#extra2 = extra + extra // batch_size *2 - 1
    	#extra3 = extra2 + extra2 // batch_size 
    	no_of_sublist = (len(yearlist_complete) + extra ) // batch_size
    	if (((len(yearlist_complete) + extra ) % batch_size))<=batch_size/2:
    		no_of_sublist = no_of_sublist
    	else:
    		no_of_sublist = no_of_sublist + 1
    else:
        no_of_sublist = 1           

    x=0
    print('total years',len(yearlist_complete))
    print('extra',extra)
    print('no of batches',no_of_sublist)
    for i in range(no_of_sublist):
    	start = x
    	finish = start+batch_size
    	if finish+batch_size-int(batch_size/2)>=len(yearlist_complete):
    		finish=len(yearlist_complete)
    	x=x+batch_size-2
    	year_dict['yearlist'+str(i)]=yearlist_complete[start:finish]
    
    #temp_correction_list=['combined_yearly_prediction','direct_application']
    #temp_correction_list=['combined_yearly_prediction']
    for i in temp_correction_list:
        print('Temporal correction for ',i)
        for x, y in year_dict.items():
            print(x, '-->',y)
            TempCorrection(input_folder,district_name,y,i)

'''
Rule-based post-classification correction
merge the monthly predictions and overall median prediction to get a single prediction for year
Pixel value 0 denotes Background, 1 denotes greenery, 2 denotes water, 3 benotes Built-Up, 4 denotes Barren land
Input-
1) monthly_pixel_predictions = list of predicted value of a particular pixel in the best 5 months of a particular year
2) median_pixel_prediction = predicted value of the above pixel over the year median image
'''  
def merge_prediction(monthly_pixel_predictions):    
    total_predictions = len(monthly_pixel_predictions)
    
    #find the count of each kind of pixel value for a pixel across all the given years
    background_count = monthly_pixel_predictions.count(0)
    green_count = monthly_pixel_predictions.count(1) 
    water_count = monthly_pixel_predictions.count(2) 
    builtup_count = monthly_pixel_predictions.count(3) 
    barrenland_count = monthly_pixel_predictions.count(4) 
    
    #Applying different rules for post-classification error correction
    
    # Rule1: If pixel is predicted as background in all selected predictions, consider it background for the entire year
    if (background_count == total_predictions):
        return '0'
    # Rule2: If a pixel is predicted same in all predictions keep it as it is.
    elif (green_count>=1 and max([barrenland_count,builtup_count,water_count])==0):
    	return '1'
    elif (water_count>=1 and max([green_count,barrenland_count,builtup_count])==0):
    	return '2'
    elif (barrenland_count>=1 and max([green_count,water_count,builtup_count])==0):
    	return '4'
    elif (builtup_count>=1 and max([green_count,barrenland_count,water_count])==0):
    	return '3'    
    
    # Rule3: (pixel has been predicted as water and green atleast once)
    #If pixel is predicted as water more times than green in quarterly predictions, 
    # consider it water for the entire year
    elif (water_count > 0 and green_count > 0):
        return '2' if (water_count >= 2 * green_count) else '1'

    #Rule3: (pixel has been predicted as bareland and green atleast once)
    # that means that area has grass at some point of time. Classify it as green area.
    # Choose green between barrenland and green	
    elif (green_count >0 or barrenland_count>0):
    	return '1'
    	#return '1' if(green_count>=barrenland_count) else '4'


    # Rule3: majority based rule  for remaining (builtup, bareland, green, water)
    elif (green_count >= max([green_count,water_count,builtup_count,barrenland_count])):
        return '1' 
    elif (barrenland_count >= max([green_count,water_count,builtup_count,barrenland_count])):
        return '4' 
    elif (water_count >= max([green_count,water_count,builtup_count,barrenland_count])):
        return '2'         
    else:
    	return '3'

#method to make grayscale images(.png) into colorful images. Input is the folder name containing grayscale images.
def make_images_colorful(input_folder, greyscale_folder):
	print(greyscale_folder)
	src_folder_path = input_folder+'/results/'+greyscale_folder
	colored_folder = greyscale_folder+'_colored'
	colored_folder_path = input_folder + '/results/' + colored_folder 
	os.makedirs(colored_folder_path, exist_ok=True)
	for infile in os.listdir(src_folder_path):
		if infile[-4:]=='.png':
			image_path = src_folder_path+'/'+infile
			img = Image.open(image_path)
			img = img.convert("RGBA")
			pixdata = img.load()
			for y in range(img.size[1]):
				for x in range(img.size[0]):
					if pixdata[x, y] == (0, 0, 0, 255):      # background 
						pixdata[x, y] = (0,0,0,0)            # black color
					elif pixdata[x, y] == (1, 1, 1, 255):    # green
						pixdata[x, y] = (34,139,34, 255)     # green color
					elif pixdata[x, y] == (2, 2, 2, 255):    # water
						pixdata[x, y] = (2, 4, 251, 255)     # blue color
					elif pixdata[x, y] == (3, 3, 3, 255):    # built-up 
						pixdata[x, y] = (255, 255, 102, 255) # yellow color
					elif pixdata[x, y] == (4, 4, 4, 255):    # bareland
						pixdata[x, y] = (255, 80, 80, 255)   # red color

			img.save(colored_folder_path+"/"+infile[:-4]+'_colored.png')
			print(infile + ' - colors filled.')

flag_overlapping_TempCorrection = False
batch_size_overlapping = 6
temp_correction_list=['direct_application','combined_yearly_prediction']
# temp_correction_list=['combined_yearly_prediction']
year_list = ['2016', '2019']

input_folder = 'Hardoi'     #we have stored monthly predections in a folder named by district name
if input_folder.split('/')[-1]=='':
	input_folder = input_folder[:-1]
district_name = input_folder.split('/')[-1]
if (district_name==""): #if user has put extra "/" at the end of input folder path.
	district_name = input_folder.split('/')[-2]

print('Name of Area/District - ',district_name)

output_folder = 'Results/'+input_folder
os.makedirs(output_folder,exist_ok=True)

print('''
        -------------------------------------------------------
        Creating sub-folders structure and
        Converting .tif files into .png for further processing.  
        -------------------------------------------------------
	''')

total_count=0
for infile in os.listdir(input_folder):
    if infile[-4:] == ".tif":
        total_count = total_count+1
        for year in year_list:
            os.makedirs(output_folder+"/"+year,exist_ok=True)
            if (year in infile):
                #shutil.move(input_folder+'/'+infile, output_folder+'/'+year+'/'+infile)
                shutil.copy(input_folder+'/'+infile, output_folder+'/'+year+'/'+infile)
print("Total .tif files found in the root folder - ", total_count)

for year in year_list:
	main_folder = output_folder + '/' + year
	os.makedirs(main_folder+"/pngs",exist_ok=True)
	count = 0
	for infile in os.listdir(main_folder):
		if infile[-4:] == ".tif":                   #reading all tif files in given folder
			im = Image.open(main_folder+"/"+infile)
			im.save(main_folder+"/pngs/"+infile[:-4]+'.png')
			count=count+1
	print(count, ' images found and converted for year ',year )		
print('.tif to .png conversion completed.')

print('''
	-----------------------------------------------
	Segregating yearly median prediction 
	and making them colorful.
	-----------------------------------------------
	''')
'''
Make a year_median folder and copy all the yearly_median_prediction for all years in that folder.
'''
os.makedirs(output_folder+"/results/direct_application",exist_ok=True)
for year in year_list:
	src_dir = output_folder + '/' + year + '/pngs'
	dest_dir = output_folder+"/results/direct_application"
	for infile in os.listdir(src_dir):
		if ('year_median' in infile):
			shutil.copyfile(src_dir+'/'+infile, dest_dir+'/'+district_name+'_prediction_'+year+'.png')

make_images_colorful(output_folder, "direct_application")

##=========================================Rule based approach =======================================================

print('''
	-----------------------------------------------
	Processing for final_year_prediction started.
	 (Please wait. This might take few minutes.)
	-----------------------------------------------
	''')

os.makedirs(output_folder+"/results/combined_yearly_prediction",exist_ok=True)
for year in year_list:
	main_folder = output_folder + '/' + year
	#Find the minimum number of background pixels in the images of all months for this year
	dataset = [ np.asarray(Image.open(main_folder+"/pngs/"+infile)) for infile in os.listdir(main_folder+"/pngs/") ]
	image_dimension = dataset[0].shape
	#print(image_dimension)

	#Initializing the results prediction matrix for a particular year
	results_prediction = np.zeros(image_dimension[0] * image_dimension[1]).reshape(image_dimension)
	#print(results_prediction)

	for i in tqdm.tqdm(range(image_dimension[0]), desc='Progress : '):
	    for j in range(image_dimension[1]):
	        x = [ dataset[k][i][j] for k in range(len(dataset)) ]
	        results_prediction[i,j] = merge_prediction(x)

	print("final_prediction "+year +" - ",np.unique(results_prediction,return_counts=True))
	results_prediction = (Image.fromarray(results_prediction)).convert("L")
	results_prediction.save(output_folder+'/results/combined_yearly_prediction/'+district_name+'_prediction_'+year+'.png')        
print('done!')

print('''
	-----------------------------------------------
	final_year_prediction done.
	Making final_year_prediction colorful for you!
	-----------------------------------------------
	''')   


make_images_colorful(output_folder, "combined_yearly_prediction")

##========================================= Temp Correction procedure =========================================================			

print('''
	---------------------------------------------------
	Combined_yearly_prediction for all years completed.
	Temporal correction begins...
	---------------------------------------------------
	''')  


if flag_overlapping_TempCorrection==True:
	print("Temporal correction is being done with overlapping of two years with batches of "
		+ batch_size_overlapping + ' years')
	Overlapping_TempCorrection_execution(output_folder, district_name, year_list, temp_correction_list, batch_size_overlapping)
else:
	print("Temporal correction is being done for all years together.")
	for folder_name in temp_correction_list:
		TempCorrection(output_folder, district_name, year_list, folder_name)		

print('''
	-------------------------------------------------------
	Making temporal corrected predictions colorful for you!
	-------------------------------------------------------
	''')  
#-----------------------------------------------------
for folder_name in temp_correction_list:
	temp_coorected_folder_name = folder_name + '_temp_corrected'
	make_images_colorful(output_folder, temp_coorected_folder_name)


print('''
	-----------------------------------------------
	 Congratulations! We are done with everything.
	-----------------------------------------------
	''')